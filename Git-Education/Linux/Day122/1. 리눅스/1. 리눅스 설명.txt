1장 리눅스 첫 걸음
cp a.txt b.txt
ls a*
grep "abc" sample.txt | sort

exit
exit 명령어는 셸을 종료하는 명령어지만, 셸이 종료되면 자동적으로 로그아웃됩니다. 이와는 별도로 logout이란 명령어가 있는데 이 명령어는 현재 셸이 로그인 셸이어야만 동작합니다.
따라서 logout 명령어보다는 exit 명령어를 사용하는 것이 좋다.

슈퍼 사용자로 전환하기
$sudo su -
사용자 암호
#
슈퍼 사용자가 되면 프롬프트의 기호가 $에서 #으로 바뀐다.

셧다운 실행. -h 전원을 끄는 것을 의미
shutdown -h now

재부팅 실행
shutdown -r now

명령어를 찾지 못할 때
/sbin/shutdown -h now

2장 셸이란 무엇인가
윈도나 맥 같은 운영 체제에서는 마우스로 컴퓨터를 조작하지만 리눅스는 키보드로 명령어를 입력하는 방식을 더 많이 사용한다. 이때 리눅스와 사용자를 연결하는 것이 바로 셸이다.

2.1 셸과 명령어
date 현재 시간을 출력하거나 설정
echo 인자로 인정한 문자열을 출력
abcde 
Command 'abcde' not found

로그인 쉘 확인하기
echo $SHELL

일시적으로 셸 바꾸기
현재 사용중인 셸을 sh로 변경
sh

sh로 바꾼 상태에서 bash  실행
bash

다시 원래 쉘로 돌아간 것처럼 보이지만, 실은 bash -> sh -> bash를 기동한 상태이다. 즉, 셸 위에 셸이 중첩되어 실행된 것이다.

이렇게 셸 위에서 기동한 셸은 로그인 셸이 아닌 일반 셸(비로그인 셸)이다. 그래서 logout 명령어로 로그아웃하려고 하면 에러가 발생한다.

비로그인 셸에서는 logout 명령어로 종료할 수 없다.

비로그인 셸에서 빠져나오려면 exit 명령어를 사용해야 한다. 원래의 배시 셸로 돌아오려면 exit를 두 번 입력해야 한다.

로그인 셸 자체를 변경하려면 cshs 명령어를 사용한다. 하지만 이 명령어를 잘못 사용하면 로그인이 안 되는 문제가 발생할 수 있다. 특별한 이유가 없다면 로그인 셸은 기본으로 설정된 bash를 사용하는 것이 좋다.

터미널이란

터미널이란 컴퓨터의 입출력만을 담당하는 전용 하드웨어를 말한다. 입력 장치인 키보드와 출력 장치인 모니터로 구성된다. 데이터 센터에는 간혹 입출력 기능만 갖춘 간이 단말기(dumb terminal)가 있다.
하지만 현재 리눅스를 다룰 때 하드웨어 터미널을 사용하는 경우는 거의 없다. 대신에 소프트웨어로 구현한 터미널 에뮬레이터가 사용된다. 터미널 에뮬레이터는 리눅스, 윈도, 맥 등에서 애플리케이션으로 동작한다.

주요 터미널 에뮬레이터

운영체제			터미널 에뮬레이터
Windows			PuTTY, Tear Term
macOS X			terminal, iTerm2
Linux			GNOME Terminal, Konsole

터미널과 셸
터미널 에뮬레이터와 셸은 완전히 다른 소프트웨어이니 혼동하면 안 된다. 예를 들어 윈도에서 리눅스로 원격 로그인하면 터미널 에뮬레이터는 윈도머신에서 돌아가며, 셸은 리눅스 머신에서 돌아간다.
터미널 에뮬레이터는 입출력 화면을 제공만하는 소프트웨어이다.

3장 셸을 능숙하게 다루는 방법
셸에서 프롬프트 기호($) 뒤에 명령어를 입력하는 부분을 커맨드 라인(행)이라고 한다.
ctrl + b		한 문자 뒤로 이동(backward)
ctrl + f		한 문자 앞으로 이동(forward)
ctrl + a		커서를 맨 앞으로 이동
ctrl + e		커서를 맨 뒤로 이동
Meta + b		한 단어 뒤로 이동
Meta + f		한 단어 앞으로 이동

여기서 Meta는 일반적인 키보드에서 다음 키에 해당한다.(Esc, Alt)

BackSpace 또는 ctrl + h	커서 위치 기준으로 뒤에 있는 한 문자를 삭제
Delete 또는 ctrl + d	커서 위치의 한 문자를 삭제
ctrl + w			커서 뒤에 공백이 나오기 전까지 있는 문자들(단어)를 삭제

ctrl + k			커서의 위치에서 끝까지 삭제
ctrl + u			커서의 위치에서 커맨드 라인의 첫 문자까지 삭제
ctrl + y			마지막으로 지운 내용을 삽입

윈도나 macOS에서는 자르고 붙이기를 cut & paste라고 표현하지만, bash에서는 붙이기(paste)를 양크(yank)라고 한다.

ctrl + s		화면 표시를 잠근다.
ctrl + q		화면 표시 잠금을 해제한다.

ctrl + s 로 출력을 잠가도 문자열은 계속 입력된다. 화면에 아무것도 표시되지 않는다고 아무 문자나 입력하지 말고 침착하게 ctrl + q를 눌러 보자.

리눅스의 일부 명령은 실행한 뒤 명시적으로 종료하지 않으면 계속 실행 상태에 있다. 이러한 명령을 실행하면 프롬프트로 돌아오지 않기 때문에 직접 종료해야 한다. 실행 중인 명령을 강제 종료하려면 Ctrl + c를 누른다.

ping 192.168.2.67

네트워크 연결을 확인하는 명령어인 ping을 사용했다. 이 명령어는 1초에 1번씩 네트워크 접속을 무한히 확인하기 때문에 종료할려면 ctrl + c 를 눌러야 한다.
또한 커맨드 라인에서 명령을 입력하다가 ctrl + c를 누르면 새로운 커맨드 라인으로 넘어갈 수 있다.

프롬프트의 문자가 깨지는 경우
이미지 파일 같은 바이너리 파일을 셸에서 출력하면 프롬프트의 문자가 깨지는 경우가 있다. 이때에는 화면을 지우는 ctrl + l(엘) 을 입력한다.

ctrl + l (엘)		화면을 삭제한다.

ctrl + l 은 화면에 표시되는 내용을 전부 지우고 커서를 화면 좌측 상단으로 이동시킨다. clear 명령어와 동일한 기능을 수행한다. 불필요한 정보를 지워서 화면을 깨끗하게 만들고 싶을 때 사용한다.
ctrl + l 을 입력해도 여전히 문자가 깨진다면 reset 명령어를 사용한다. reset은 이름 그대로 터미널을 초기화하는 명령어로 터미널의 표시에 문제가 있을 때 시용한다. 그래도 문제가 계속된다면 일단 로그아웃한 뒤 로그인하면 해결되는 경우가 많다.

배시의 자동 완성 기능은 Tab을 사용한다.

ec + tab		echo 자동완성
e + tab
터미널의 설정에 따라 다르지만 보통 경고음(벨이 울린다고 표현한다.)이 울리고 자동 완성이 동작하지 않는다. 이는 자동 완성될 후보가 많다라는 bash의 메시지이다. 여기서 한 번 더 Tab을 눌러보자.
이번에는 명령어 목록이 출력된다. 전부 e로 시작하는 명령어들이다.

이렇게 편리한 자동 완성 기능은 명령어뿐만 아니라 파일 이름에도 적용할 수 있다.

명령 이력
bash는 한 번 입력한 커맨드 라인을 기록해 둔다. 이러한 명령 이력 기능을 활용하면 이전에 입력한 명령들을 다시 불러올 수 있다.

ctrl + p 혹은  ↑ 		바로 전 명령으로 이동한다. (previous)
ctrl + n 혹은  ↓		다음 명령으로 이동한다.(next)

명령 이력 검색
ctrl + r 을 입력하면 명령 이력을 검색할 수 있다.
셸에서 ctrl + r을 입력하면 프롬프트가 다음과 같이 중분 검색이라는 모드로 변경된다.
문자를 하나씩 입력할 때마다 검색 결과 갱신

(reverse-i-search)`e': env
(reverse-i-search)`ec': echo Hello

참고 history 명령의 목록을 볼 수 있다.
!번호	해당 명령 실행

중분 검색
(문자 입력)	문자를 하나씩 입력할 때마다 검색을 수행합니다.
ctrl + r		한 개 이전의 검색 결과로 이동합니다.
enter		현재 검색 결과를 실행합니다.
esc		현재 검색 결과를 실행하지 않은 채 커맨드 라인으로 복귀합니다.
ctrl + g		검색 결과를 지우고 프롬프트로 복귀합니다.

man ascii 를 입력하면 ASCII 코드를 확인할 수 있다.
(ascii 매뉴얼이 보이지 않는다면, sudo dnf install man-pages)

printenv LANG	현재 어떤 문자 코드가 사용되는지 확인

문자코드를 변환하려면 iconv 명령어를 사용하면 된다. 예를 들어 EUC-KR로 작성된 텍스트 파일을 UTF-8으로 변환하고 싶다면 다음과 같이 -f(FROM)에 EUC-KR을, -t(TO)에 UTF-8을 지정하면 된다.

iconv -f EUC-KR -t UTF-8 <파일 이름>

4장 파일과 디렉터리
리눅스는 파일로 구성된다.

리눅스는 파일로 구성된다. 먼저 정보(데이터), 이를테면 문서, 이미지, 영상, 프로그램 등이 파일로 보존된다. 
또한 리눅스에서는 사용자의 데이터뿐만 아니라 시스템을 구성하는 장치조차도 파일로 다룬다. 
예를 들어 하드 디스크, 키보드, 프린터 같은 입출력 장치를 전부 파일로 다룬다. 심지어 리눅스 커널도 파일이고 
시스템 설정도 파일에 기록된다.
즉, 리눅스에서는 모든 것을 파일로 다루기 때문에 파일 조작 방법을 익히는 것이 중요하다.

디렉터리란
파일의 개수가 많아지면 종류별로 분류하는 것이 좋다. 여러 개의 파일을 담아서 정리할 수 있는 것이 디렉터리이다. 
윈도나 맥의 폴더 개념과 동일하다.
디렉터리 안에 있는 디렉터리를 서브 디렉터리 혹은 자식 디렉터리라고 부른다. 
반대로 어떤 디렉터리 위에 있는 디렉터리를 부모 디렉터리라고 한다.

리눅스의 디렉터리 구조
디렉터리 구조.png 참고

맨 위에 있는 / 디렉터리를 루트 디렉터리라 한다. 
모든 파일과 디렉터리의 부모를 찾아 올라가면 루트 디렉터리에 도달하게 된다.
루트 디렉터리 아래에 디렉터리와 파일이 있는 계층 구조를 트리 혹은 디렉터리 트리라고 한다. 
루트를 뿌리라고 생각하고 그 아래에 파일이나 디렉터리를 잎이라고 생각하면 나무와 흡사하다는 것을 알 수 있다.

1. PATH
특정 파일을 '루트 디렉터리 아래의 usr 디렉터리 아래의 bin 디렉터리 아래에 있는 perl이라는 파일'이라고 표기하는 건 
무척 비효율이다. 그래서 다음과 같이 디렉터리 사이에 /(슬래시)를 넣어 /usr/bin/perl과 같이 표기한다. 
그리고 이를 해당 파일에 대한 경로(path)라고 한다.
경로에서 디렉터릴르 구분하기 위해 사용하는 문자로 리눅스에서는 /를 사용하고, 윈도에서는 보통 \를 사용한다.

2. 윈도와의 차이
윈도도 리눅스와 비슷한 디렉터리 트리 구조를 가진다. 
하지만 윈도에서는 물리 디스크가 2개 있다면 디렉터리 트리도 2개이다. 
하지만 리눅스에서는 언제나 시스템 전체에 단 하나의 트리만 가지게 된다.
리눅스에서는 디스크가 여러 개 있을 때 루트 디렉터리의 어딘가에 해당 디스크의 디렉터리가 연결된다. 
이렇게 디스크의 디렉터리를 연결하는 것을 마운트라 한다.

3. 각 디렉터리의 역할
리눅스의 디렉터리 구조는 FHS(Filesystem Hierachy Standard)라는 표준 사양을 따른다. 
자세한 내용은 다음 웹 페이지에서 PDF 파일을 내려받아 참고하면 된다.
cf) 리눅스에서는 디렉토리를 파일취급하기 때문에 파일이름과 겹치면 안된다

Filesystem Hierachy Standard
https://www.pathname.com/fhs/

/bin
일반 사용자 및 관리자가 사용하는 명령어의 실행 파일이 배치되어 있는 디렉터리이다. 
/bin는 특히 시스템과 관련된 중요도가 높은 명령어를 포함하고 있다.

/dev
디바이스 파일이 배치되어 있는 디렉터리이다. 
디바이스 파일이란 디스크나 키보드 등 하드웨어를 다루기 위한 특수 파일이다.

/etc
리눅스에서 돌아가는 다양한 애플리케이션의 설정 파일이 /etc 아래에 배치된다. 
애플리케이션뿐만 아니라 리눅스 자체의 설정 파일도 이곳에 있다. 
따라서 리눅스를 운영하고 관리할 때 무척 중요한 디렉터리이다.

/home
사용자별로 할당되는 홈 디렉터리가 배치되는 디렉터리이다. 홈 디렉터리란 사용자별로 할당되는 개인용 디렉터리를 말한다. 사용자 이름이 디렉터리 이름으로 사용된다. 예를 들어 사용자 이름이 ldk라면 사용자의 홈 디렉터리는 /home/ldk가 된다. 사용자는 홈 디렉터리 안에서 자유롭게 파일이나 디렉터리를 작성해 작업할 수 있다.

/sbin
/bin와 비슷하게 실행 파일을 포함하는 디렉터리이다. 
그런데 이 디렉터리에는 관리자용 명령어가 포함되어 있다. 
예를 들어 1장에서 소개한 시스템을 종료시키는 shutdown 명령어가 이 안에 있다.

/tmp
임시 파일이 들어 있는 디렉터리이다. 
애플리케이션 실행 중 임시로 작업 결과를 파일로 보존할 때 보통 이 디렉터리에 저장한다. 
정기적으로 이 디렉터리 안의 파일을 삭제하도록 설정된 배포판도 있으므로 중요한 파일을 /tmp에 보관하면 안 된다.

/usr
설치한 애플리케이션의 실행 파일, 문서, 라이브러리 등이 이 디렉터리에 포함된다. 
/usr 아래에는 bin, sbin, etc 등이 있어 루트 디렉터리와 구조가 비슷하다.

/var
변화하는 (variable) 데이터를 저장하기 위한 디렉터리이다. 
애플리케이션 실행 중에 만들어진 데이터나 로그, 메일 등이 이곳에 저장된다. 
/var에는 많은 파일이 기록되므로 용량이 부족해질 수도 있으니 시스템을 관리할 때 주의해야 한다.

현재 디렉터리와 pwd
리눅스를 사용하다 보면 많이 디렉터리를 이동하면서 작업하게 된다. 이때 현재 위치한 디렉터릴르 현재 디렉터리, 
영어로 current directory 혹은 working direcotry라고 한다. 

pwd	pwd 명령어로 현재 디렉터리 출력

절대 경로와 상대 경로

1. 절대 경로
/usr/bin/perl 처럼 루트 디렉터리부터 해당 파일에 이르는 경로를 표시하는 것을 절대 경로라 한다.
절대 경로는 해당 파일의 위치를 명확하게 나타내지만, 
디렉터리의 깊이가 깊으면 경로가 너무 길어진다는 문제가 있습니다. 
또한, 시스템별로 절대 경로가 달라서 여러 시스템에서 사용하기에는 무리가 있습니다.

2. 상대 경로
현재 디렉터리의 위치를 기준으로 표기하는 경로를 상대 경로라고 한다. 
상대 경로를 사용할 때는 특수 디렉터리인 . 와 .. 을 사용할 수 있습니다.

. 는 현재 디렉터리를 뜻한다.  
현재 디렉터리에 있는 파일 file-2의 위치를 좀 더 명확하게 표기하기 위해 ./file-2라고 표기할 수 있다.
.. 는 부모 디렉터리를 의미한다. 
즉, 현재 디렉터리의 위에 있는 디렉터리를 지정하기 위해 사용한다. 
..를 연속해서 사용하면 부모 디렉터리 위의 부모 디렉터리를 나타낸다. 
가령 ../../../../는 현재 디렉터리를 기준으로 4개 위의 디렉터리를 뜻한다. 
그리고 ../miyake라고 하면 부모 디렉터리 아래의 miyake를 뜻한다.

cd /usr		/usr 디렉터리로 이동
pwd		현재 디렉터리 출력
ls		현재 디렉터리의 파일과 디렉터리를 출력 (list)
cd lib		lib 디렉터리로 이동
pwd		현재 디렉터리 출력

cd /usr		절대 경로 지정
cd ..		상대 경로 지정

경로 자동 완성

cd /u + 탭
cd /usr/lo + 탭

cd		아무런 인자를 쓰지 않은 채 cd 명령어를 실행하면 홈 디렉터리로 이동한다.
cd ~		홈 디렉터리로 이동

커맨드 라인에서 틸드는 셸에 의해 사용자의 홈 디렉터리 경로로 치환된다. 셸의 이러한 기능을 틸드 확장이라 한다.

$cd ~/report       = cd /home/hong/report         cf) mkdir report : make directory
$pwd
/home/ldk/report

ls 명령어

ls /		루트 디렉터리의 목록을 출력f      cf) 결과가 안나온다면? 출력결과를 보는 권한이 없을경우!
ls /bin/cp		/bin/cp의 목록을 출력
ls / /usr		/ 와 /usr의 목록을 출력

*와 ?
ls 명령어의 인자로 여러 파일을 지정할 때 일일이 모든 파일을 타이핑하는 것은 번거로운 일이다. 
이때 배시에 있는 경로 확장 기능으로 파일 이름의 패턴을 지정할 수 있다. 
경로 확장은 와일드카드 확장 혹은 파일 이름 글로브(glob)라고도 불리우며 *(애스터리스크)와 ?(물음표)기호를 사용한다.

경로 확장에서 사용하는 기호
*		임의의 문자열
?		임의의 한 문자

ls ba*		ba로 시작하는 목록을 출력하는 코드
ls *.html		확장자가 html로 끝나는 목록을 출력하는 코드
ls ba??		ba로 시작하고 뒤에 두자가 있는 목록을 출력하는 코드

ls -l		-l 옵션으로 상세 정보를 함께 출력

-l 옵션을 표시되는 정보는 다음과 같다.

d파일타입   링크스		소유그룹
drwxr-xr-x  20 	root 	root 	4096 	9월 26 00:12 	var
  파일모드		소유주		크기	타임스탬프	파일 이름 또는 디렉터리 이름

- 보통파일
d 디렉터리
l 심볼릭 링크

ls -a	-a 옵션으로 숨겨진 파일도 출력

ls 명령어는 기본적으로 .로 시작하는 파일을 숨긴 파일이라고 판단하고 출력하지 않는다. 
하지만 -a 옵션을 지정하면 숨겨진 파일도 출력한다.
그리고 -F 옵션을 붙이면 파일 이름 뒤에 파일의 종류를 의미하는 기호를 추가해 출력한다.

-F 옵션으로 표시되는 파일의 종류

종류		기호
보통파일		표시되지 않음
디렉터리		/
실행가능파일	*
심볼릭링크	@	

옵션 지정

ls -a
ls -a -F
ls -aF

옵션과 인자를 동시에 지정하는 예
ls -a -F /

옵션의 인자를 지정

예를 들어 ls 명령어의 -w 오면은 지정한 값에 맞게 문자 간격을 맞춰 출력한다.
ls -w 30
이 예서는 문자를 30개씩 출력하도록 지정. 여기서 30이란 ls 명령어의 인자가
아니라 옵션 -w의 인자이다.
또한, 옵션의 인자를 지정할 때는 스페이스를 생략할 수 있다. 따라서 다음 두 명령의
결과는 동일하다.

ls -w 30
ls -w30

롱 옵션
일반적인 옵션은 '하이픈+영숫자 한 문자'의 형식이지만, --처럼 하이픈 두 개로 시작하는 옵션 형식도 있다. 
예를 들면 --quote-name 같은 옵션이 있다. 이 옵션을 사용하면 파일 이름을 "로 묶어서 출력한다.

ls --quote-name
롱 옵션에서는 다른 옵션과 혼동될 여지가 없으면 뒷부분을 생략하는 것이 가능한다. 
예를 들어 --quote-name 롱 옵션은 --quote라고 줄여도 된다.

ls -quote

롱 옵션은 그 뜻이 명확하기 때문에 한 문자로 구성된 옵션에 대해 롱 옵션도 함께 제공하는 경우가 있다. 
예를 들어 앞서 설펴본 -w 옵션의 롱 옵션은 --width 이다.
인자의 롱 옵션은 옵션과 인자 사이에 공백을 주거나 = 기호를 사용한다. 
따라서 다음 두 방식은 동일한 옵션을 지정한 것이 된다.

ls --width 30
ls --width=30