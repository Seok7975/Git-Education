5장 깃허브로 협업하기

5.1 깃허브 소개
깃허브는 왜 사용할까요? 먼저 깃허브는 개발자의 SNS입니다. 그리고 백업을 할 수 있고 개발자 간 협업을 가능케 하는 원격 저장소 호스팅 서비스이기도 합니다.

Recent Repositories는 최근 이용한 저장소
All activity는 팔로우하는 사람들의 활동 내역
Explore repositories는 깃허브가 추천해주는 저장소

여느 SNS와 마찬가지로 깃허브에도 사용자 프로필이 있습니다. 우측 상단의 동그란 아이콘을 클릭해 보세요. 참고로 동그란 아이콘 속 그림은 현재 기본으로 설정된 여러분의 프로필 이미지입니다. 여기에서 Your profile을 클릭해 보세요.
그럼 여러분의 프로필 페이지로 이동합니다. 아직 여러분은 어떤 저장소도 업로드하지 않았고, 프로필을 꾸미기 전이기 때문에 'You don't have any public repositories yet.'이라는 메시지만 뜰 뿐 보이는 정보는 많지 않습니다.

URL을 확인해 볼까요? 
https://github.com/계정 이름  
형식으로 되어 있죠? 깃허브에서는 이와같은 URL을 통해 특정 사용자의 프로필을 조회할 수 있습니다.

리누스 토르발스의 깃허브
https://github.com/torvalds

1. 깃허브 첫 페이지에서 우측 상단의 동그란 아이콘을 클릭하고 Settings에 들어가 보세요.
2. 계정 설정 화면에서 Profile 메뉴를 선택하면 이름, 이메일, 설명 등을 작성하고 프로필 사진을 업로드할 수 있는 공간이 나옵니다. 여기에서 여러분의 이름과 이메일을 작성하고, 프로필 사진을 업로드해 보세요.
3. 다 입력했다면 스크롤을 내려 Update profile을 클릭하세요.
4. 조금 기다렸다가 새로고침하면 업데이트된 프로필을 볼 수 있습니다.

이제 깃허브에 올라온 유명한 저장소를 탐방해 봅시다. 예를 들어 텐서플로를 검색해 보겠습니다. 텐서플로는 오픈 소스로 깃허브에 모든 소스 코드가 공개되어 있습니다. 상단 검색 창에 tensorflow를 입력하고 검색해 보세요.
그러면 tensorflow와 관련한 프로젝트들이 검색됩니다. tensorflow/tensorflow 프로젝트를 클릭합니다.
우측을 보면 Star가 있습니다. 이는 SNS의 '좋아요'와 같습니다. SNS 속 마음에 드는 게시물에 '좋아요'를 누를 수 있는 것처럼 여러분도 마음에 드는 오픈 소스 프로젝트에 STAR를 눌러 호감을 표시할 수 있습니다.
아래 쪽을 보면 몇 개의 commit이 쌓여 있는 지 볼수 있다.

아래로 스크롤을 쭉 내려보세요. 텐서플로 프로젝트와 관련한 안내가 적힌 화면을 볼 수 있다.
README.md는 해당 프로젝트의 설치 방법, 사용 방법 등을 담고 있는 파일이다. 일종의 안내서라고 생각해도 좋습니다. 깃 저장소에 README.md 파일을 업로드하면 README.md 파일에 적힌 내용이 보입니다.
또한, 깃허브에서는 Issues로 오류를 제보하거나, 더 다양한 기능을 제안할 수도 있습니다. 스크롤을 다시 최상단으로 쭉 올리고 Issues를 클릭해 보세요.

텐서플로와 관련한 다양한 이슈를 확인할 수 있습니다. 텐서플로와 관련한 오류를 제보하는 이슈도 있고, 새로운 기능을 제안하는 이슈도 있습니다.

2. 원격 저장소 호스팅 서비스, 깃허브
원격 저장소를 통해 얻을 수 있는 이점에는 크게 두 가지가 있습니다. 바로 백업과 협업입니다.

원격 저장소 만들기
1. 우측 상단의 +를 클릭한 뒤 New repository를 클릭해 보세요.
///////////////////////////////////////////////////////////
tip
원격 저장소는 프로필 페이지의 'Repositories'에서 'New'를 클릭해 생성할 수도 있습니다.
//////////////////////////////////////////////////////////

2. 여기에서 새로 만들 원격 저장소의 정보를 입력합니다.
원격 저장소의 이름(Repository name)에는 test-repo를, 설명(Description)에는 My first github repository!를 입력했습니다. 그 아래에서는 Public으로 설정한 뒤 나머지 내용은 그대로 두고 Create repository를 클릭하면 원격 저장소가 생성됩니다.

각 항목을 추가로 설명하면 다음과 같습니다.

우선 Owner는 원격 저장소의 소유자입니다. Repository name은 원격 저장소의 이름입니다. Description은 여러분이 만들 원격 저장소에 대한 설명을 적는 공간인데, 기입하지 않아도 무방합니다.

그리고 아래에 Public과 Private 중 하나를 선택할 수 있는 곳이 있죠? Public은 모두에게 공개된 저장소를 의미하고 Private은 모두에게 공개하지 않고 여러분(또는 여러분이 지정한 일부 사용자)만 볼 수 있는 저장소를 의미합니다.

그 아래를 보면 Add a README file, Add .gitignore, Choose a license를 선택하는 항목도 있습니다. Add a README file은 원격 저장소를 생성할 적에 자동으로 README 파일을 생성해주는 항목입니다. 마찬가지로 Add .gitignore를 선택하면 원격 저장소를 생성할 때 자동으로 .gitignore를 생성해 줍니다. Choose a license는 이 저장소에 담길 프로젝트의 라이선스를 선택하는 항목입니다.

3. 여러분이 방금 만든 저장소 URL은 
https://github.com/계정 이름/저장소 이름 
형식으로 되어 있습니다. 이와 같은 URL로 특정 사용자의 저장소에 접근할 수 있다는 것도 알아두기 바랍니다.

////////////////////////////////////
TIP
이렇게 생성한 원격 저장소는 'Settings' 메뉴의 최하단에 있는 'Delete this repository'를 클릭해 삭제할 수도 있습니다.
////////////////////////////////////

5.2 원격 저장소와의 네 가지 상호 작용

1. 클론(clone) : 원격 저장소를 복제하기
2. 푸시(push) : 원격 저장소에 밀어넣기
3. 패치(fetch) : 원격 저장소를 일단 가져만 오기
4. 풀(pull) : 원격 저장소를 가져와서 합치기

1. 소스트리와 깃허브 연동하기
소스트리와 깃허브가 SSH 통신할 수 있도록 연동하겠습니다. SSH(Secure Shell)는 안전하게 정보를 주고 받을 수 있는 통신 방법입니다. 
다시 말해, 소스트리와 깃허브가 서로 SSH 통신이 가능하도록 연동하면 여러분의 컴퓨터(로컬 저장소)와 깃허브(원격 저장소)는 서로 안전하게 정보를 주고받을 수 있습니다.
SSH 통신하려면 먼저 여러분의 컴퓨터에서 키(key) 두 개를 생성해야 합니다. 하나는 공개 키(public key), 또 다른 하나는 개인 키(private key)입니다. 공개 키는 모두에게 공개된 키, 개인 키는 여러분만 알고 있어야 하는 키입니다. 여기서 키는 영어로 열쇠라는 뜻이지만, 여기서는 암호, 또는 암호화된 문자열이라고 생각해도 좋습니다.
공개 키와 개인 키를 생성한 뒤 통신하려는 대상에게 공개 키를 건네줍니다. 여러분은 깃허브와 SSH 통신할 예정이니 깃허브에게 공개 키를 전해주면 되겠죠?
SSH 통신은 암호화된 통신 방법이므로 여러분과 (공개 키를 전달받은) 깃허브 사이에 주고받는 대화는 암호화되어 전송됩니다. 다른 누군가각 여러분과 깃허브 사이에 주고받는 대화를 엿듣는다고 해도 전혀 이해할 수 없지요. 다만, 여러분은 개인 키가 있어서 깃허브에 여러분임을 증명하고, 깃허브와 주고받는 내용을 이해할 수 있씁니다.
매우 간략히 설명했지만, SSH는 개발 전반에서 많이 활용하는 통신 방법이므로 꼭 알아도는 것이 좋습니다. 그럼 SSH 키를 생성해 봅시다. 미리 말하자면 다음 과정은 외울 필요가 없습니다. 한 번 SSH 키를 생성해 연동하면 계속 통신할 수 있기 때문입니다. 편한 마음으로 차근차근 따라 하면 되겠습니다.

1. SSH 키는 ssh-keygen 이라는 간단한 명령으로 생성할 수 있습니다. 깃 배시 창을 열고(파일 탐색기에서 오른쪽클릭해서 선택) ssh-keygen을 입력하면 개인 키(id_rsa)를 저장할 경로를 선택하라는 문구가 나옵니다. 엔터
2. 'Enter passphrase (empty for no passphrass)' 뜹니다. 여러분이 사용하려는 암호를 입력한 뒤 Enter를 누르거나, 암호를 사용하지 않으려면 아무것도 입력하지 않고 Enter를 누릅니다.
3. 'Enter same passphrase again'이 떴다면 앞서 입력한 암호를 한 번 더 입력한 후 Enter를 누르세요. 암호 없이 사용하기로 했다면 그냥 Enter를 누르면 됩니다.
4. 출력된 문구를 통해 저장된 경로와 키를 확인하세요.
5. 이제 소스트리로 돌아와 도구 > 옵션을 클릭하세요.
6. SSH 클라이언트 설정의 SSH 클라이언트를 클릭하면 PuTTY / Plink와 OpenSSH 두 선택 항목이 보입니다. PuTTY/Plink를 통해 공개 키와 개인 키를 생성할 수 있고, OpenSSH를 통해서도 공개 키와 개인 키를 생성할 수 있습니다. 앞서 키를 만든 방식은 OpenSSH 방식입니다. OpenSSH를 선택하고 확인을 선택하여 옵션 창을 닫아주세요.
/////////////////////////////////
TIP
SSH 클라이언트를 OpenSSH로 선택했을 때 SSH 키 항목에 앞서 생성한 개인 키 경로가 자동으로 등록되었다면 바로 뒤 7번과 8번은 따라 할 필요 없습니다.
////////////////////////////////
7. 도구 > SSH 키 추가를 클릭하세요.
8. 앞서 두 키가 저장된 경로에서 개인 키를 선택한 후 열기를 클릭하세요.
9. 도구 > 옵션을 다시 열어 SSH 키가 잘 등록됐는지 확인합니다.
10. 이제 여러분의 컴퓨터와 통신할 깃허브에게 공개 키를 건네주러 가봅시다. 깃허브에 접속한 뒤 프로필 이미지를 클릭해 Settings에 들어갑니다.
11. 좌측 메뉴에서 SSH and GPG keys를 클릭해 주세요.
12. New SSH key를 클릭합니다.
13. 여기에 여러분의 공개 키를 등록하면 됩니다. Title 항목에는 여러분의 임의대로 키의 제목을 쓰고, Key 항목에는 공개 키 파일안에 적힌 내용을 넣으면 됩니다. 공개키 파일을 열어 복사한 후 Key 항목에 붙여넣습니다. 그리고 Add SSH key를 눌러주세요.
14. 자, 그럼 다시 소스트리로 돌아와 보세요. Remote를 클릭합니다. 여기에서 여러분의 깃허브를 등록하겠습니다. 계정 추가를 클릭하세요.
15. 호스팅 서비스는 GitHub를, 선호 프로토콜은 SSH를 선택한 뒤 OAuth 토큰 새로고침을 눌러보세요.
16. 이때 브라우저에 아틀라시안 인증을 확인하는 화면이나옵니다.
17. 이 경우 스크롤을 내려 Authorize Atlassian을 누르세요.
18. Authentication Successful 화면이 보인다면 다시 소스트리로 이동해 주세요.
19. 인증 성공이라는 표시가 뜨면 성공적으로 연동된 것입니다. 확인을 클릭합니다.
20. 소스트리에서 여러분의 깃허브 계정이 뜬다면 성공입니다. 우측을 보면 여러분이 만든 원격 저장소 test-repo도 볼 수 있습니다. 혹시 원격 저장소가 뜨지 않는다면 새로고침을 클릭하세요.


2. 클론 : 원격 저장소 복제하기

클론(clone). 이는 말 그대로 깃허브상에 존재하는 원격 저장소를 여러 분의 컴퓨터, 즉 로컬로 복사하여 가져오는 방법입니다.
여러분이 직접 만든 원격 저장소뿐 아니라 깃허브상에 공개된 모든 원격 저장소를 여러분의 컴퓨터로 클론하여 가져올 수 있습니다.
예를 들어 보겠습니다. 가령 다음 링크 속 원격 저장소를 여러분의 컴퓨터로 복제하겠습니다.

https://github.com/namhyung/uftrace

1. 예제 링크에 접속한 뒤 Code를 클릭해 보세요. SSH를 클릭한 뒤 소스 경로를 소스 경로를 복사합니다.
///////////////////////////////////////////////////////////////////////////////////////////////
TIP
DownloadZIP을 클릭하면 원격 저장소의 내용을 압축 파일 형태로 내려받을 수 있습니다.
////////////////////////////////////////////////////////////////////////////////////////////////
2. 이제 소스트리를 열고 Clone을 클릭한 뒤 소스 경로 / URL 항목에 앞서 복사한항목을 붙여넣습니다. 목적지 경로에는 여러분의 컴퓨터 속 클론할 경로를 기입하면 됩니다. 필자는 C:\uftrace 라는 경로에 클론하겠습니다.
이름은 복사할 원격 저장소의 이름을 나타내는데, 자동으로 기입됩니다. 잘 입력됐는지 확인한 후 클론을 클릭하세요.
3. 원격 저장소에 쌓인 커밋들을 볼 수 있습니다.
4. 클론된 위치로 가서 확인해 봅시다. 원격 저장소를 클론하면 원격 저장소의 .git 폴더까지 복사됩니다.
이런 식으로 클론을 통해 여러분은 다양한 원격 저장소를 여러분의 컴퓨터로 복제할 수 있습니다. 여기까지 잘 따라오셨다면 클론한 저장소를 삭제해도 좋습니다.
5. 그렇다면 이번에는 여러분이 직접 만든 원격 저장소를 클론해 봅시다. test-repo를 클론 해봅시다.
6. 소스트리로 돌아와 Remote를 클릭하면 여러분의 원격 저장소 목록이 표시됩니다. 여기서 클론하려는 원격 저장소를 선택할 수 있습니다. test-repo를 클론하려면 test-repo 옆에 있는 Clone을 클릭해야 합니다.
7. C:\test-repo 경로에 클론하겠습니다.
8. 유일한 커밋으로 보이는 Initial commit은 test-repo의 README.md 파일이 추가되며 만들어진 커밋입니다.
9. 클론한 위치로 가보면 test-repo의 내용을 확인할 수 있습니다.

다시 소스트리로 돌아옵니다. 여기서 브랜치의 이름에 주목해 주세요. main, origin/main, origin/HEAD, 이렇게 브랜치 세 개가 보입니다.

좌측에서도 브랜치에 main, 원격에 origin/HEAD, origin/main 브랜치를 볼 수 있지요.

이 브랜치들은 무엇일까요? 앞서 깃에서 관리하는 기본 브랜치는 master 브랜치라고 설명했습니다.

main 브랜치는 master 브랜치와 같습니다. 다시 말해 깃허브에서는 기본 브랜치를 main 브랜치라고 부릅니다. 클론하면 원격 저장소가 그대로 로컬로 복제된다고 했죠? 그래서 로컬로 클론한 저장소의 기본 브랜치 이름도 깃허브의 기본 브랜치 이름과 동일한 main이 되는 것입니다.
원래 깃허브에서도 기본 브랜치를 master 브랜치라고 지칭했으나, master라는 단어가 차별적인 어감을 담고 있기 때문에 2020년부터 기본 브랜치를 master에서 main으로 바꾸어 부르기로 했습니다.
origin/HEAD, origin/main은 원격 저장소 origin의 HEAD와 기본 브랜치를 지칭합니다. 여기서 origin은 원격 저장소 경로에 붙은 일종의 별명입니다. 소스트리 우측 상단의 설정을 클릭해 볼까요?
원격 저장소 경로를 보면 이름에 origin, 경로는 원격 저장소를 클론할 때 사용한 경로가 적혀 있습니다. 원격 저장소를 지칭할 때 매번 경로(git@github.com:...)를 사용하는 것은 번거로우니 단순히 origin이라고 부르기로 한 것입니다.
origin은 원격 저장소에 붙은 이름일 뿐이므로 언제든 수정할 수 있습니다 다만, 이 예시에서는 origin을 그대로 사용하겠습니다.

3. 푸시 : 원격 저장소에 밀어넣기

원격 저장소와의 상호 작용, 그 두 번째는 푸시(push)입니다. 푸시는 영어로 '밀다'라는 뜻입니다. 깃에서 사용하는 push는 원격 저장소에 로컬 저장소의 변경 사항을 밀어넣는 것을 의미합니다.
이는 예시를 보며 이해하는 것이 좋습니다. 앞 절에서 test-repo라는 원격 저장소를 클론했습니다. 클론이 뭐라고 했죠? 원격 저장소를 여러분의 컴퓨터로 복제하는 것이라 했습니다. 따라서 현재 원격 저장소 test-repo와 로컬 저장소(여러분의 컴퓨터 속) test-repo의 상태는 동일합니다.
그럼 이 상태에서 로컬에서 커밋을 추가한 뒤 이를 원격 저장소에 푸시하는 예를 실습해 보겠습니다.
1. 로컬 저장소 test-repo를 수정해 봅시다. 문자 A가 담긴 a.txt 파일을 추가합니다.
2. 이를 커밋해 보겠습니다. 커밋 메시지는 add a.txt로 하겠습니다.
로컬 저장소에는 이제 막 두 번째 커밋이 추가됐고, 원격 저장소에는 커밋 하나만 존재합니다.
3. 이 상태에서 원격 저장소를 로컬 저장소와 같게 만들려면, 다시 말해 a.txt 파일을 원격 저장소에 추가하려면 로컬의 변경 사항을 원격 저장소에 푸시해야 합니다. 상단의 Push를 클릭해 보세요.
4. 원격 저장소 깃허브를 확인해 봅시다. a.txt 파일이 잘 추가됐을 뿐 아니라 커밋 수가 두 개로 늘었네요.
5. 여기에서 원격 저장소의 커밋 내역들을 볼 수 있습니다. 로컬에서 만든 두 번째 커밋을 확인할 수 있죠?
6. 한 번 더 해봅시다. 이번에는 a.txt 파일을 삭제하고, B가 저장된 b.txt 파일을 추가해 보겠습니다.
7. 이를 커밋합니다. 커밋 메시지는 delete a.txt and add b.txt로 하겠습니다.
8. 커밋이 잘 됐다면 Push를 클릭하세요.
9. 푸시가 완료되면 깃허브에서 세 번째 커밋을 확인할 수 있습니다.

4. 패치 : 원격 저장소를 일단 가져만 오기

원격 저장소와의 상호 작용, 그 세 번째는 패치(fetch)입니다. fetch는 '가져오다'를 의미합니다. 다시 말해, 패치는 원격 저장소의 변경 사항들을 가져오는 방법, 더 정확하게는 일단 가져만 오는 방법입니다. 원격 저장소의 변경 사항을 '일단 가져만 온다'는 게 무슨 의미일까요? 차근차근 알아봅시다.
/////////////////////////////////////////////////////////////////////////////////
TIP
패치(fetch)와 패치(patch)는 발음이 유사하지만 엄연히 다른 용어임에 유의해 주세요.
//////////////////////////////////////////////////////////////////////////////////

지금까지의 실습을 잘 따라왔다면 현재 로컬 저장소와 원격 저장소의 상태는 같을 것입니다. 로컬 저장소에 커밋이 세 개 쌓여 있고, 원격 저장소 또한 커밋이 세 개 쌓여 있습니다. 로컬 저장소에 README.md와 b.txt 파일이 있고, 원격 저장소에도 README.md와 b.txt 파일이 있습니다.
현재 원격 자장소 test-repo는 오로지 여러분만 사용하고 있지만, test-repo를 여러 개발자가 협업하여 개발하고 있는 상황을 가정해 봅시다. 다른 개발자가 언제든 test-repo에 새로운 변경 사항을 추가할 수 있기 때문에 test-repo는 시시각각 변할 수 있습니다.
다른 개발자가 푸시한 내용을 여러분의 로컬로 가져오고 싶을 때 패치를 사용할 수 있습니다. 다시 말해, 원격 저장소의 변경 사항을 로컬로 가져오고 싶을 때 패치를 사용합니다.

이 상황을 직접 실습해 보겠습니다. 깃허브에서는 자신의 원격 저장소 내의 파일을 직접 수정하고 커밋할 수 있습니다.

1. 깃허브에서 b.txt 파일을 직접 수정하고, 커밋을 추가하겠습니다. 원격 저장소 test-repo에 접속해 b.txt 파일을 클릭합니다.
2. 연필 아이콘을 클릭합니다.
3. 여기에서 b.txt 파일을 수정합니다. 두 번째 줄에 
This is written in Github
라고 적습니다.
4. Commit changes 를 클릭하면 수정한 내용을 바탕으로 새로운 커밋이 만들어집니다.
커밋 메시지는 간단하게 update b.txt in github를 적고, Commit changes 를 클릭하겠습니다.(Add an optional extended description은 커밋 메시지의 본문에 해당하는 내용이므로 적지 않아도 무방합니다.)
5. 새로운 커밋이 만들어졌습니다. b.txt 파일이 수정된 것이 보입니다.
6. 또한 커밋 개수도 네 개가 됐습니다.
7. 그렇다면 원격 저장소의 변경 사항을 패치해 보겠습니다. 소스트리 상단의 패치를 클릭합니다.
8. 확인을 클릭하면 패치가 됩니다.
9. 깃허브에서 작성한 네 번째 커밋을 볼 수 있습니다.

브랜치 이름에 주목해 보세요. 로컬의 main 브랜치는 여전히 세 번째 커밋을 가리키고, origin/main 브랜치는 네 번째 커밋을 가리킵니다. 로컬 저장소의 브랜치가 변경되지 않았죠? 즉, 패치해도 원격 저장소의 내용이 로컬 저장소에 병합되지 않습니다. 그래서 패치를 '원격 저장소의 변경 사항을 일단 가져만 오는 방법'이라고 설명한 것입니다.

main 브랜치를 origin/main 브랜치와 병합해 볼까요? main 브랜치를 origin/main 브랜치와 병합하면 어떻게 될까요? 로컬의 main 브랜치도 네 번째 커밋을 가리키게 되겠지요?

10. origin/main 브랜치에 마우스 오른쪽 버튼을 클릭한 후 병합을 클릭해 보세요.
11. '병합 확정' 창이 뜨면 확인을 클릭합니다.
12. 자, 이렇게 원격 저장소의 변경 사항을 로컬 저장소에 병합했습니다.
13. 이제 로컬 저장소의 b.txt 파일을 클릭하면 깃허브에서 작성한 네 번째 커밋을 볼 수 있습니다.


5. 풀: 원격 저장소를 가져와서 합치기

패치가 원격 저장소를 '일단 가져오는 방법' 이라면 풀(pull)은 원격 저장소를 '가져와서 합치는 방법'입니다. 즉, 풀은 패치와 병합을 동시에 하는 방법입니다. 실습하며 알아볼까요?

풀(pull) = 패치(fetch) + 병합(merge)

1. 깃허브 속 원격 저장소로 접속합시다. 앞서 깃허브에서 파일을 직접 수정하여 새로운 커밋을 만들 수 있다고 했죠? 깃허브에서는 원격 저장소에 새로운 파일을 생성하거나 업로드할 수도 있습니다. Add file을 클릭하여 Create new file을 클릭해 보세요.
2. c.txt 파일을 만들고, 안에는 This file is created in github를 작성해 보세요.
3. 커밋 메시지로 create c.txt in github를 작성하고 Commit new file을 클릭합니다.
4. c.txt라는 새로운 파일 생성됐고, 커밋은 총 5개로 증가했습니다.
5. 소스트리로 돌아와 봅시다. 이제 깃허브에서 생성한 변경 사항, 즉 c.txt 파일을 만든 다선 번째 커밋을 풀 해보겠습니다. 상단의 Pull를 클릭해 보세요.
6. origin의 main 브랜치를 로컬 저장소의 main 브랜치로 풀 해보겠습니다. Pull를 클릭하세요.
7. main 브랜치가 다섯 번째 커밋을 가리키고 있죠? 다시 말해, 원격 저장소의 새로운 변경 사항이 로컬 저장소로 바로 병합된 셈입니다. 즉, 풀을 하게 되면 원격 저장소의 변경 사항이 즉시 로컬로 병합됩니다.
8. 실제로도 c.txt 파일이 생성된 것을 확인할 수 있습니다. 이렇듯 풀은 원격 저장소의 변경 사항을 로컬 저장소에 바로 병합하는 방식이라는 점에 유의해 주세요. 패치와 풀의 차이점을 아는 것이 중요합니다.

정리해 보겠습니다. 원격 저장소와 상호 작용하는 방식에는 크게 네 가지 클론, 푸시, 패치, 풀이 있습니다.

클론은 원격 저장소를 로컬로 복제하여 가져오는 방법입니다. 푸시는 로컬 저장소의 변경 사항을 원격 저장소로 밀어넣는 방법입니다. 패치는 원격 저장소의 변경 사항을 일단 가져만 오는 방법입니다. 병합을 하진 않는 방식이지요. 풀은 원격 저장소의 변경 사항을 가져와서, 병합까지 해주는 방법입니다.

5.3 풀 리퀘스트 : 깃허브로 협업하기
마지막으로 깃허브로 다른 개발자와 협업하는 방법에 대해 알아봅시다. 한 원격 저장소에 여러 개발자가 코드를 기여할 수 있습니다. 실무에서도 여러 개발자가 한 원격 저장소를 두고 개발하는 것이 일반적이지요.
여기서 궁금증이 생깁니다. 앞선 절에서 여러분은 여러분이 소유한(여러분이 직접 만든) 원격 저장소에 푸시해 보았습니다. 그런데 여러분이 소유하지 않은 원격 저장소에도 푸시할 수 있을까요? 일반적으로 그렇지 않습니다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Collaborator로 추가하여 푸시 권한 주기
원격 저장소 소유자가 여러분을 Collaborator로 추가한 경우에는 여러분이 소유하지 않은 계정의 원격 저장소에 푸시할 수 있습니다.
가령 first-github-user가 소유한 원격 저장소 test-repo가 있다고 합시다. 다른 계정은 이 저장소에 푸시할 권한이 없습니다. 하지만 first-github-user가 특정 계정을 Collaborator로 추가하면 Collaborator로 등록된 계정은 test-repo에 푸시할 수 있게 됩니다.
여러분이 소유한 원격 저장소(여기에서는 test-repo)의 Settings에서 Collaborators를 클릭한 뒤 Add people을 클릭해 보세요.
Add a collaborator to test-repo 항목에 Collaborator로 등록할 계정 이름을 입력하세요.
Add kangtegong to this repository를 누르면 kangtegong 계정의 이메일로 collaborator 요청이 전송됩니다. kangtegong이 이를 승인하면 kangtegong은 collaborator 로서 first-github-user의 test-repo에 직접 푸시할 수 있습니다.
하지만 이는 다음에 설명할 이유들 때문에 권장하는 방법이 아니며, 대부분 직접 푸시할 권한이 없는 상태에서 풀 리퀘스트(pull request)로 협업합니다.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

원격 저장소에 누구나 푸시할 수 있다면 여러 문제가 발생할 수 있습니다. 만일 누구나 허락없이 소유하지도 않은 원격 저장소에 푸시할 수 있다면 원격 저장소의 소유자가 원하지도 않는 변경 사항들이 원격 저장소에 마구 추가되는 불상사가 발생할 수 있습니다.

아니, 이건 삭제하고 싶지 않은데!?
심지어 저 파일은 잘못 수정했잖아?
저 파일은 뭐야?
왜 추가한거야?

그렇다면 푸시 권한이 없는 원격 저장소에 어떻게 코드를 밀어넣을 수 있을까요? 어떻게 다른 원격 저장소에 변경 사항을 추가할 수 있을까요?

풀 리퀘스트(pull request)를 통해 가능합니다. 풀 리퀘스트는 말 그대로 원격 저장소가 내 변경 사항을 풀(pull) 하도록 요청(request)하는 방법입니다. 즉, '내가 당신의 원격 저장소를 이렇게 변경하고 싶은데, 이 변경을 당신의 저장소로 풀 해주세요!'하고 부탁하는 방법이지요.

풀 리퀘스트는 다음 단계를 통해 이루어집니다. 처음에는 이 내용이 익숙하지 않고 복잡하게 느껴질 수 있지만, 몇 번 반복하다 보면 자연스레 익숙해질 테니 천천히 읽어보면 눈도장을 찍어보세요.

1. 기여하려는 저장소를 본인 계정으로 포크하기
2. 포크한 저장소를 클론하기
3. 브랜치 생성 후 생성한 브랜치에서 작업하기
4. 작업한 브랜치 푸시하기
5. 풀 리퀘스트 보내기

아, 이런 요청이 들어왔구나. 검토해보고 마음에 들면 받아들여야지.

이 파일을 삭제하고 싶어요. 이 변경을 풀 해주세요.
이 파일을 수정하고 싶어요. 이 변경을 풀 해주세요.
이 파일을 추가하고 싶어요. 이 변경을 풀 해주세요.

자신의 계정에 collaboration_이름으로 새 repository를 만든다.
그리고 index.html을 다음 내용으로 만든다.

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>본인이름</li>
    </ul>
</body>
</html>

index.html의 내용입니다. 이제부터 여러분이 실습할 일은 조장에게 풀 리퀘스트를 보내 여러분의 계정 이름을 이 파일 안에 적어넣는 것입니다. 더 정확하게는 </ul>의 윗 줄에 <li>여러분 계정 이름</li>을 적어넣는 것입니다.

이 원격 저장소는 조장이 소유한 저장소이기 때문에 여러분은 이 저장소에 직접 푸시할 수 없습니다. 그러니 여러분은 조장에게 'index.html 변경한 내용을 풀 해주세요!' 하며 풀 리퀘스트를 보내야 합니다. 이제 풀 리퀘스트를 실습해 봅시다.

1. 풀 리퀘스트의 첫 번째 단계는 기여하려는 저장소를 본인 계정으로 포크하기입니다.
포크(fork)란 원격 저장소를 여러분의 계정으로 복제하는 방법입니다. Fork를 눌러보세요.
2. 포크하면 여러분의 계정으로 조장 계정의 collaboration이 복제됩니다. 조장의 저장소를 여러분의 계정으로 복제했기 때문에 여러분은 복제된 저장소에 푸시할 수 있습니다.
다시 말해, 여러분은 여러분이 소유하지 않은 원격 저장소에 직접 푸시할 수 없지만, 여러분의 계정으로 포크(복제)한 원격 저장소에는 푸시할 수 있습니다.
3. 풀 리퀘스트의 두 번째 단계는 포크한 저장소를 클론하기입니다.
여기서 조장의 저장소가 아닌 포크한 저장소, 즉 여러분 계정으로 복제한 저장소를 클론하는 것이 중요합니다. 소스트리로 돌아와 collaboration 저장소를 클론해 보세요.
4. c:\collaboration 경로로 collaboration 저장소를 클론하겠습니다.
5. 풀 리퀘스트의 세 번째 단계는 브랜치 생성 후 생성한 브랜치에서 작업하기입니다. 클론이 잘 됐다면 새로운 브랜치를 생성해 봅시다. 상단의 브랜치를 클릭하세요.
6. 브랜치의 이름은 add_username 이라는 이름의 브랜치를 생성하겠습니다.
7. 브랜치가 생성됐다면 해당 브랜치에서 작업하기 위해 생성한 브랜치로 체크아웃합니다.
8. 자, 이제 작업을 수행하면 됩니다. 이번 실습에서는 index.html을 수정하기로 했었죠?
9. 여러분의 계정 이름을 <li> 태그로 추가하겠습니다. 다음과 같이 </ul> 태그 바로 윗 줄에 여러분의 깃허브 계정 이름을 추가해 주세요.

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>조장이름</li>
        <li>본인이름</li>
    </ul>
</body>
</html>

10. 이제 네 번째 단계, 작업한 브랜치 푸시하기입니다. 수정한 index.html을 add_username 브랜치에 커밋하겠습니다. 커밋 메시지는 add my username in index.html로 남기겠습니다.
11. 새로 생성한 브랜치에서 커밋을 추가했다면 이를 푸시해 봅시다. 상단의 Push를 클릭하세요.
12. 작업한 add_username 브랜치를 푸시하기 위해 add_username을 클릭한 뒤 Push를 클릭합니다. 새로 생성하고 작업한 브랜치를 푸시한다는 것에 유의해 주세요.
13. 자, 이제 마지막 단계는 풀 리퀘스트 보내기입니다. 깃허브 속 포크한 저장소로 돌아와 보세요. 상단에 Compare & pull request가 생성됐습니다. 이를 클릭해 보세요.
14. 여러분의 작업 내역을 볼 수 있습니다. 여러분이 작업한 것은 </ul> 태그 위에 (줄 간격을 맞춰) <li>여러분의 계정 이름</li>을 추가하는 일이었죠? 풀 리퀘스트를 생성하기 직전에 이렇게 여러분의 작업을 한번 확인하는 습관을 들이는 것이 좋습니다. 확인했다면 Create pull request를 클릭합니다.
15. 이렇게 풀 리퀘스트가 생성됐습니다.
16. 이제 조장/collaboration 저장소의 Pull requests 메뉴에서 여러분의 풀 리퀘스트를 확인할 수 있습니다. 이제 이 원격 저장소의 소유자, 즉 조장이 여러분의 풀 리퀘스트를 검토하고, 여러분의 작업에 문제가 없다면 이를 저장소에 병합할 것입니다.
여기서부터는 풀 리퀘스트를 받은 사람(조장)의 시점입니다. 풀 리퀘스트 하단에 Merge pull request가 있습니다. 이를 클릭하여 풀 리퀘스트를 병합할 수 있습니다.
여러분의 풀 리퀘스트에 댓글을 남길 수도 있지요.
저장소의 소유자가 여러분의 풀 리퀘스트를 병합하면 다음과 같이 풀 리퀘스트의 상태가 Open에서 Merged로 변경됩니다.
풀 리퀘스트가 병합(merged)되면 이제 여러분은 조장/collaboration 저장소에서 여러분의 작업을 확인할 수 있습니다. 즉, 조장/collaboration 저장소의 index.html에서 여러분의 계정 이름을 확인할 수 있습니다.

정리해 보겠습니다. 풀 리퀘스트를 보내는 과정은 다음과 같습니다.
1. 기여하려는 저장소를 본인 계정으로 포크하기
일반적으로 여러분이 소유하지 않은 원격 저장소에는 푸시할 수 없습니다. 그렇기에 여러분의 계정으로 원격 저장소를 복제해와야 하는데, 이 과정을 포크라고 했습니다.
2. 포크한 본인 계정의 저장소를 클론하기
여러분이 소유하지 않은 원격 저장소에 푸시하기는 불가능할 지 몰라도 포크한 원격 저장소에 푸시하기는 가능합니다. 그래서 포크한(여러분의 계정으로 복제된) 저장소를 클론합니다.
3. 브랜치 생성 후 생성한 브랜치에서 작업하기
새로운 브랜치를 생성한 후 해당 브랜치에서 변경 사항을 만들고 커밋합니다.
4. 작업한 브랜치 푸시하기
생성한 브랜치를 푸시합니다. 그러면 깃허브에 풀 리퀘스트 버튼이 생성됐죠.
5. 풀 리퀘스트 보내기
마지막으로 풀 리퀘스트를 보내면 끝이 납니다.