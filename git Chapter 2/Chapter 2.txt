로컬 저장소를 만들면 .git이라는 숨김 폴더가 생성된다.
.git 숨김 폴더가 놓여 있는 곳이 우리의 프로젝트가 위치할 공간이다. 이 공간, 즉 우리의 프로젝트가 위치할 공간을 작업 디렉터리 또는 작업 트리(working tree)라고 한다. 작업 디렉터리는 버전 관리의 대상이 위치하는 공간이다.
'버전을 만든다'는 말은 '특정 순간의 변경 사항을 기억한다'는 말과 같다. 그렇기에 작업 디렉터리에 있는 프로젝트에 변경 사항이 생기는 순간 새로운 버전을 만들 수 있게 된다. 이 변경 사항은 새로운 파일이 추가되는 것일 수도 있고, 특정 파일을 수정하거나 삭제하는 것일 수도 있다.
 깃으로 버전을 만들 때는 작업 디렉터리 내에서 변경된 파일들 중에서 새로운 버전이 될 파일만 특별한 공간으로 옮기는 작업을 거치게 된다. 이 특별한 공간이 바로 스테이지이다. 즉, 스테이지는 변경 사항이 있는 파일 중 다음 버전이 될 후보가 올라가는 공간인 셈이다. 
스테이지는 스테이징 영역(staging area) 또는 인덱스(index)라고도 부른다. 참고로 작업 디렉터리는 프로젝트가 위치한 공간이라 눈으로 직접 볼 수 있는 반면, 스테이지는 명시적으로 보이지 않는다.
다음 버전이 될 후보들을 모두 스테이지로 옮겼다면 이제 이 파일을 새로운 버전으로 만들어야겠죠. 스테이지에 있는 파일을 바탕으로 새로운 버전을 만들면 새 버전이 저장소에 추가된다. 작업 디렉터리에서 만들어진 모든 버전들의 내역이 저장소에 있다. 즉, 저장소는 버전이 만들어지고 관리되는 공간이다.
참고로 저장소는 스테이지와 마찬가지로 사용자에게는 명시적으로 보이지 않는다.
스테이지에 올라온 파일을 토대로 새로운 버전을 만들면 새로운 버전이 될 후보가 더 존재하지 않으니 스테이지는 깨끗하게 비워진다.

이러한 과정을 반복하며 저장소에는 새로운 버전들이 차곡차곡 쌓이게 된다.
이때 작업 디렉터리에서 버전이 될 후보 파일을 스테이지로 옮기는 것을 '스테이지에 추가한다(add)' 또는 '해당 파일을 스테이지시킨다.(staged)'라고 표현한다. 그리고 스테이지에 추가된 파일을 '추가된(add) 파일' 또는 '스테이지된(staged) 파일'이라고 표현한다.
또한, 저장소에 새로운 버전을 만드는 것을 '커밋한다(commit)'라고 표현한다. 저장소에 저장된 버전들을 커밋이라 부르기도 한다.

정리하자면, 작업 디렉터리의 파일은
1. 변경 사항 생성
2. add
3. commit

의 과정을 통해

1. 작업 디렉터리
2. 스테이지
3. 저장소
순으로 이동하며 새로운 버전으로 만들어진다.

첫 버전 만들기

로컬 저장소 만들기
1. 소스트리 실행 후 Create를 누른다.
2. 목적지 경로에 로컬 저장소를 생성할 경로를 설정하고, 이름은 이와 동일하게 입력한다. 이 책에서는 목적지 경로를 c:\git-test로 설정했다. 모두 입력한 후 생성을 누른다.
3. 우측 상단의 탐색기를 클릭하여 git-test가 잘 만들어졌는지 확인해 보자.
.git 숨김 폴더가 보인다면 성공적으로 로컬 저장소를 만든 것이다. 그리고 이 경로(C:\git-test) 가 작업 디렉터리이다. 깃으로 버전을 관리할 대상을 여기에 놓으면 된다.

버전을 관리할 대상 만들기
1. 작업 디렉터리에 a.txt, b.txt, c.txt라는 텍스트 파일을 만들고, 각각의 파일 안에 text file a, text file b, text file c를 적은 뒤 저장한다.
(줄 바꿈을 하고 저장한다.
줄 바꿈을 하지 않고 저장하면 스테이지에 올릴 때 경고 메시지가 뜰 수 있기 때문이다. - \ NO newline at end of file -)
경고 메시지는 무시해도 무방하지만, 이러한 메시지가 뜨지 않게 하려면 파일 내에 저장할 내용을 적고 줄 바꿈을 한 뒤에 저장해야 한다.)

2. 텍스트 파일을 작성한 뒤 저장하면 소스트리의 파일 상태에서 스테이지에 올라가지 않은 파일 항목에 방금 생성한 파일들이 추가된다.
스테이지에 올라가지 않은 파일은 말 그대로 '작업 디렉터리 내 변경 사항이지만, 아직 버전이 될 후보로 선정되지는 않은 파일'을 말한다.

3. 모두 스테이지에 올리기를 클릭하여 모든 파일을 스테이지에 올리면 a.txt, b.txt, c.txt파일이 스테이지에 올라간 파일 항목에 표시된다.

/////////////////////////////////////////////////////////////////////////////////
참고
스테이지에 파일을 올리는 방법
다음과 같은 방식으로 변경 사항이 생긴 파일을 스테이지에 올릴 수 있다.
* 스테이지에 올라가지 않은 파일 전체를 올리는 방법: 모두 스테이지에 올리기를 클릭합니다.
* 파일별로 올리는 방법: 파일 이름 우측의 +를 클릭합니다.
* 선택한 파일만 올리는 방법: Ctrl을 누른 채 스테이지에 올리려는 파일을 클릭한 후 선택 내용 스테이지에 올리기를 클릭합니다.
참고로 스테이지에 올라간 파일 항목에서 파일 이름 우측의 -를 클릭하면 해당 파일은 스테이지에서 내려온다. 즉, 버전이 될 후보에서 제외하는 것이다.
/////////////////////////////////////////////////////////////////////////////////////

4. 각 파일을 클릭하면 각 파일의 변경사항을 볼 수 있다. 초록색 표시와 + 표시는 각 파일에서 새롭게 추가된 내용을 의미한다.


커밋 메시지 작성하기

커밋 메시지란 버전을 설명하는 메시지이다. '내가 지금 어떤 파일을 어떻게 변경했는지, 왜 이렇게 변경했는지' 등의 내용을 담은 일종의 쪽지라고 보면된다.

커밋 메시지는 크게 제목과 본문으로 이루어져 있으며 본문은 생략할 수 있습니다. 첫 줄에는 제목을 쓰고, 한 줄 띄고 다음 줄에는 본문을 작성한다.

1. 첫 줄에 제목을 적고, 한 줄을 띄고 다음 줄에 본문을 작성한 후 커밋 버튼을 클릭한다.

////////////////////////////////////////////////////////////////
첫 번째 커밋

a.txt, b.txt, c.txt 추가

/////////////////////////////////////////////////////////////////

2. 커밋되며 첫 번째 버전이 만들어졌습니다. 커밋을 완료하면 파일 상태에는 커밋할 내용이 없다고 표시된다.
3. 우리가 만든 커밋(버전) 내역들은 History에서 볼 수 있습니다. History를 클릭하면 커밋들의 커밋 메시지, 만들어진 시간, 작성자 등을 확인할 수 있다.

커밋 쌓아 올리기

이번에는 방금 만든 첫 번째 버전을 수정한, 또 다른 버전을 만들어 보자.

1. a.txt 파일 안에 새로운 줄로 changed를 추가한 뒤 저장한다. 그리고 c.txt 파일은 삭제해 보자.
2. 소스트리로 들어가 보면 History에 '커밋하지 않은 변경 사항'이 추가된 것을 확인할 수 있다.
3. 좌측의 파일 상태를 클릭해 보자. 스테이지에 올라가지 않은 파일에서 a.txt 파일과 c.txt 파일을 볼 수 있따.
4. 두 변경 사항을 커밋하여 새로운 버전(커밋)으로 만들어 보자. 첫 번째 커밋을 만들었을 때와 동일하게 모두 스테이지에 올리기를 눌러 두 파일을 모두 스테이지에 올린다.
그리고 커밋 메시지를 작성한 뒤 커밋 버튼을 누른다.

////////////////////////////////////////////////////////////

두번째 커밋

a.txt에 changed 문구 추가. c.txt 삭제

/////////////////////////////////////////////////////////////

5. 커밋한 뒤 History로 들어가 보면 두 번째 커밋이 생성된 것을 확인할 수 있따. 여기서 그래프 항목에 주목해 보자.

동그라미 두 개가 연결되어 있는 것을 볼 수 있다. 여기서 동그라미 하나는 커밋 하나, 즉 하나의 버전을 나타낸다. '두 번째 커밋'의 동그라미가 '첫 번째 커밋'의 동그라미와 연결되어
있는 것은 두 번째 커밋이 첫 번째 커밋에서부터 만들어진 버전임을 나타낸다.

새로운 버전 만들기

text file d 라는 내용을 담은 텍스트 파일 d.txt 를 만들고, 이를 스테이지에 올린 뒤 커밋해 보자. 그리고 커밋 메시지는 다음과 같이 작성해 보자.

////////////////////////////////////////

세 번째 커밋

d.txt 파일 추가

////////////////////////////////////////////////

note
관리 대상(tracked) 파일과 관리 대상이 아닌(untracked) 파일
d.txt 파일이 추가된 버전을 만드는 과정에서 이런 의문이 들 수 있다.
"a.txt 파일을 수정하고 c.txt 파일을 삭제한 두 번째 버전을 만들 때는 펜 모양의 아이콘과 빼기 모양의 아이콘이 뜨고 새롭게 d.txt 파일을 추가한 세 번째 버전을 만들 때는 물음표 모양의 아이콘이 뜨는데, 이건 각각 무슨 의미인가?

물음표 모양의 아이콘은 깃이 기존에 변경 사항을 추적하지 않았던 새로운 파일을 의미한다. 이런 종류의 파일, 즉 기존에 깃이 관리하지 않았던 파일을 'untracked 상태'에 있는 파일이라고 한다.
반면, 깃이 변경 사항을 추적하고 있는 파일도 있다. 스테이지에 올라왔거나 한 번이라도 커밋된 적 있는 파일이 이런 파일에 속한다. 이런 파일을 'tracked 상태'에 있는 파일이라 한다.

tracked 상태의 파일이 삭제된 경우에는 c.txt처럼 빼기 모양 아이콘으로 나타내고, 수정된 경우에는 a.txt 처럼 펜 모양 아이콘으로 나타낸다.

.gitignore로 무시하기
.gitignore 파일은 쉽게 말해 '무시할 파일/폴더 목록'을 적은 파일입니다. 깃은 .gitignore 파일에 적은 파일이나 폴더에 변경 사항이 생겨도 이를 무시합니다.

1. 작업 디렉터리에 .gitignore 파일을 만듭니다. .gitignore 파일은 일반 텍스트 파일처럼 생성해도 좋다.(이때 .txt와 같은 확장자는 지우자. 깃은 정확히 .gitignore라는 파일명을 인식하기 때문이다.)
2. 생성된 .gitignore 안에 e.txt를 적은 뒤 저장하자. 이는 '깃이 작업 디렉터리 내 e.txt 파일을 무시하겠다.'는 의미이다.
3. .gitignore 파일 또한 작업 디렉터리 내에 있는 파일이기 때문에 깃은 이 파일이 만들어 진 것을 알아차릴것이다. 그렇기에 소스트리의 스테이지에 올라가지 않은 파일 항목에 .gitignore 파일이 추가된다.
4. 이제 e.txt 파일을 만들고 text file e 라고 적은 후 저장해 보자.
5. 작업 디렉터리에 e.txt 파일이 새롭게 추가됐는데도 소스트리의 스테이지에 올라가지 않은 파일 항목에 e.txt 파일이 생성되지 않는 것을 확인할 수 있다. 즉, 깃이 e.txt 파일을 무시한 것이다.
6. 이번에는 깃이 무시할 폴더도 추가해 보자. .gitignore 안에 적힌 e.txt 다음 줄에 ignore/ 라고 작성한다. /는 보통 폴더(디렉터리)를 지칭할 때 사용한다. 즉, 'ignore라는 이름의 폴더는 깃이 무시하겠다'는 의미이다.
7. 작업 디렉터리에 ignore 폴더를 만들고 ignore 폴더 안에 여러 파일을 임의로 만들어 보자.
(ignore.txt, ignore2.txt, ignore3.txt, ignore4.txt)
8. 소스트리를 보면 ignore 폴더 안의 모든 파일들이 스테이지에 올라가지 않는 파일에 추가되지 않은 것을 확인할 수 있다.

버전이 쌓여 사용자에게 선보여지기까지

커밋 자세히 보기
커다란 건물이 작은 벽돌 하나하나가 모여 만들어지듯, 커다란 프로젝트는 커밋들이 모이고 모여 만들어진다. 딥러닝에 사용되는 텐서플로는 커밋이 10만 개 이상 모여 만들어졌고, 리눅스 운영 체제는 100만 개 이상 모여 만들어졌다.

https://gihub.com/tensorflow/tensorflow
https://github.com/torvalds/linux

각 커밋에는 고유한 커밋 해시가 있다. 커밋 해시란 마치 학번, 사번과 같이 각 커밋이 가진 고유한 ID이다.
소스트리에서 우리가 만든 커밋을 확인해 보자. 언뜻 보기에는 무작위한 문자열로 이루어진 듯한 문자열이 커밋의 해시이다. 각 커밋을 클릭해서 커밋별로 다른 해시 값을 가지고 있는 것을 확인해 보자. 
그런데 해시 값의 길이가 너무 길어 보인다. 그래서 때로는 해시 값의 앞부분 일부만 활용하기도 한다.
파일 상태순 정렬 부분에서 상위 항목 또한 특정 커밋을 지칭하기 위해 짧은 커밋 해시를 사용했다. 상위 항목이란 이 커밋이 어떤 커밋에서부터 나온 것인지, 다시 말해 어떤 커밋을 변경해서 만들어진 커밋인지를 나타낸다.
커밋 해시는 커밋 메시지 등에서 특정 커밋, 즉 특정 변경 사항을 지칭할 때도 사용한다.

태그는 특정 커밋에 붙일 수 있는 꼬리표와 같다. 릴리스되는 커밋(버전)에 태그를 붙인다면 커밋이 여러 개 있는 상황에서도 의미 있는 커밋이 무엇인지 한눈에 알아보기 쉽다.

* 태그 붙이기
소스트리를 이용해 직접 태그를 붙여보자. 가령 네 번째 커밋을 사용자에게 선보이고자 한다. 사용자에게 선보일 버전은 네 번째 커밋이므로 네 번째 커밋에 태그를 붙여볼까?

1. 먼저 a.txt good를 추가하고 스테이지에 모두 올리자.
커밋 제목을 a.txt good 추가라고 커밋하자.
총 네 개의 커밋이 만들어졌다.
2. 네 번째 커밋을 선택한 상태에서 태그를 클릭하자.
3. 태그 창이 나타난다. 여기에서 태그를 새롭게 생성하거나, 생성된 태그를 제거할 수 있다. 태그 이름을 v1.0.0 이라고 적고, 태그 추가 버튼을 누르자.

tip
태그를 만들 때 '작업 사본 부모'와 '명시된 커밋' 두 항목이 보인다. 최근에 만든 커밋에 태그를 붙이고 싶을 때는 '작업 사본 부모'를 특정 커밋에 태그를 붙이고 싶을 때는 '명시된 커밋'을 선택한다.

4. 최근에 만든 커밋에 v1.0.0 태그가 잘 붙은 것을 확인할 수 있다. 좌측 태그에서도 생성한 태그를 확인할 수 있다.

이렇게 분기점이 되는 특정 커밋에 태그를 붙일 수 있다. 그리고 태그 안에는 사용자에게 선보이는 버전을 명시하게 된다.
사용자에게 선보이는 버전 표기 방식은 소프트웨어마다 다르고, 개발자가 정하기 나름이다. 어떤 소프트웨어는 이 버전을 <연도.월.일> 형태로, 어떤 소프트웨어는 <숫자.숫자.숫자> 형태로, 어떤 소프트웨어는 <숫자.숫자> 형태로 명시하기도 한다.

하지만 많은 경우, 소프트웨어 버전은 다음처럼 숫자 세 개로 표기한다.

vX.Y.Z
가장 대중적인 버전 표기법

가장 앞에 나오는 숫자는 주(Major)버전이라고 부른다. 이는 가장 중요한 버전으로, 일반적으로 새롭게 내놓은 버전이 기존에 내놓은 버전과 호환되지 않을 정도로 큰 변화가 있을 때 증가한다.
두 번째 숫자는 부(Minor) 버전이라 부른다. 일반적으로 새롭게 내놓은 버전이 기존에 내놓은 버전과 문제없이 호환되지만, 새로운 기능을 추가했을 때 증가한다.
마지막 숫자는 수(Patch) 버전이라 부른다. 일반적으로 기존에 내놓은 버전과 문제없이 호환되며 버그를 수정한 정도의 작은 변화가 있을 때 증가한다.

하나의 버전을 만드는 과정은 다음과 같다.
1. 작업 디렉터리 내의 파일을 변경하기
2. 변경한 내용 중 버전에 포함할 파일을 스테이지에 올리기
3. 커밋하기

그리고 .gitignore를 작성해 버전 관리를 하지 않을 파일이나 폴더를 자동으로 걸러낼 수 있다.
각 커밋에는 커밋 해시라는 고유한 문자열이 있고, 이렇게 쌓이고 쌓인 커밋에 태그라는 꼬리표를 붙일 수 있다. 그리고 이 꼬리표 안에는 보통 버전을 작성하는 규칙에 따라 작성된 버전을 명시하고, 사용자에게 내놓을 준비가 끝나면 이를 릴리스하게 된다.
